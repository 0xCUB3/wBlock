// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: DataModels.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

internal import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Filter list categories
enum Wblock_Data_FilterListCategory: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0
  case all // = 1
  case ads // = 2
  case privacy // = 3
  case security // = 4
  case multipurpose // = 5
  case annoyances // = 6
  case experimental // = 7
  case custom // = 8
  case foreign // = 9
  case scripts // = 10
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .all
    case 2: self = .ads
    case 3: self = .privacy
    case 4: self = .security
    case 5: self = .multipurpose
    case 6: self = .annoyances
    case 7: self = .experimental
    case 8: self = .custom
    case 9: self = .foreign
    case 10: self = .scripts
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .all: return 1
    case .ads: return 2
    case .privacy: return 3
    case .security: return 4
    case .multipurpose: return 5
    case .annoyances: return 6
    case .experimental: return 7
    case .custom: return 8
    case .foreign: return 9
    case .scripts: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Wblock_Data_FilterListCategory] = [
    .unspecified,
    .all,
    .ads,
    .privacy,
    .security,
    .multipurpose,
    .annoyances,
    .experimental,
    .custom,
    .foreign,
    .scripts,
  ]

}

/// Platform enumeration
enum Wblock_Data_Platform: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0
  case macos // = 1
  case ios // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .macos
    case 2: self = .ios
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .macos: return 1
    case .ios: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Wblock_Data_Platform] = [
    .unspecified,
    .macos,
    .ios,
  ]

}

/// Main data container for all app data
struct Wblock_Data_AppData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var settings: Wblock_Data_AppSettings {
    get {return _storage._settings ?? Wblock_Data_AppSettings()}
    set {_uniqueStorage()._settings = newValue}
  }
  /// Returns true if `settings` has been explicitly set.
  var hasSettings: Bool {return _storage._settings != nil}
  /// Clears the value of `settings`. Subsequent reads from it will return its default value.
  mutating func clearSettings() {_uniqueStorage()._settings = nil}

  var filterLists: [Wblock_Data_FilterListData] {
    get {return _storage._filterLists}
    set {_uniqueStorage()._filterLists = newValue}
  }

  var userScripts: [Wblock_Data_UserScriptData] {
    get {return _storage._userScripts}
    set {_uniqueStorage()._userScripts = newValue}
  }

  var whitelist: Wblock_Data_WhitelistData {
    get {return _storage._whitelist ?? Wblock_Data_WhitelistData()}
    set {_uniqueStorage()._whitelist = newValue}
  }
  /// Returns true if `whitelist` has been explicitly set.
  var hasWhitelist: Bool {return _storage._whitelist != nil}
  /// Clears the value of `whitelist`. Subsequent reads from it will return its default value.
  mutating func clearWhitelist() {_uniqueStorage()._whitelist = nil}

  var ruleCounts: Wblock_Data_RuleCountData {
    get {return _storage._ruleCounts ?? Wblock_Data_RuleCountData()}
    set {_uniqueStorage()._ruleCounts = newValue}
  }
  /// Returns true if `ruleCounts` has been explicitly set.
  var hasRuleCounts: Bool {return _storage._ruleCounts != nil}
  /// Clears the value of `ruleCounts`. Subsequent reads from it will return its default value.
  mutating func clearRuleCounts() {_uniqueStorage()._ruleCounts = nil}

  var performance: Wblock_Data_PerformanceData {
    get {return _storage._performance ?? Wblock_Data_PerformanceData()}
    set {_uniqueStorage()._performance = newValue}
  }
  /// Returns true if `performance` has been explicitly set.
  var hasPerformance: Bool {return _storage._performance != nil}
  /// Clears the value of `performance`. Subsequent reads from it will return its default value.
  mutating func clearPerformance() {_uniqueStorage()._performance = nil}

  var autoUpdate: Wblock_Data_AutoUpdateMetadata {
    get {return _storage._autoUpdate ?? Wblock_Data_AutoUpdateMetadata()}
    set {_uniqueStorage()._autoUpdate = newValue}
  }
  /// Returns true if `autoUpdate` has been explicitly set.
  var hasAutoUpdate: Bool {return _storage._autoUpdate != nil}
  /// Clears the value of `autoUpdate`. Subsequent reads from it will return its default value.
  mutating func clearAutoUpdate() {_uniqueStorage()._autoUpdate = nil}

  var extensionData: Wblock_Data_ExtensionData {
    get {return _storage._extensionData ?? Wblock_Data_ExtensionData()}
    set {_uniqueStorage()._extensionData = newValue}
  }
  /// Returns true if `extensionData` has been explicitly set.
  var hasExtensionData: Bool {return _storage._extensionData != nil}
  /// Clears the value of `extensionData`. Subsequent reads from it will return its default value.
  mutating func clearExtensionData() {_uniqueStorage()._extensionData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// App-wide settings
struct Wblock_Data_AppSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hasCompletedOnboarding_p: Bool = false

  var selectedBlockingLevel: String = String()

  var lastUpdateCheck: Int64 = 0

  var showAdvancedFeatures: Bool = false

  var appVersion: String = String()

  var lastTerminologySanitizationVersion: Int32 = 0

  /// Critical setup checklist state
  var hasEnabledContentBlockers_p: Bool = false

  var hasEnabledPlatformExtension_p: Bool = false

  var hasSetAllWebsitesPermission_p: Bool = false

  /// UserScript UI state
  var userscriptShowEnabledOnly: Bool = false

  /// Track user-deleted default userscripts to prevent re-adding
  var excludedDefaultUserscriptUrls: [String] = []

  /// UI state for filter page
  var isForeignFiltersExpanded: Bool = false

  /// Badge counter setting
  var isBadgeCounterEnabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Filter list data structure
struct Wblock_Data_FilterListData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var name: String = String()

  var url: String = String()

  var category: Wblock_Data_FilterListCategory = .unspecified

  var isSelected: Bool = false

  var description_p: String = String()

  var version: String = String()

  var sourceRuleCount: Int32 {
    get {return _sourceRuleCount ?? 0}
    set {_sourceRuleCount = newValue}
  }
  /// Returns true if `sourceRuleCount` has been explicitly set.
  var hasSourceRuleCount: Bool {return self._sourceRuleCount != nil}
  /// Clears the value of `sourceRuleCount`. Subsequent reads from it will return its default value.
  mutating func clearSourceRuleCount() {self._sourceRuleCount = nil}

  var lastUpdated: Int64 = 0

  var isCustom: Bool = false

  var localFilePath: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sourceRuleCount: Int32? = nil
}

/// Userscript data structure
struct Wblock_Data_UserScriptData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var url: String {
    get {return _storage._url ?? String()}
    set {_uniqueStorage()._url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return _storage._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {_uniqueStorage()._url = nil}

  var isEnabled: Bool {
    get {return _storage._isEnabled}
    set {_uniqueStorage()._isEnabled = newValue}
  }

  var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  var matches: [String] {
    get {return _storage._matches}
    set {_uniqueStorage()._matches = newValue}
  }

  var excludeMatches: [String] {
    get {return _storage._excludeMatches}
    set {_uniqueStorage()._excludeMatches = newValue}
  }

  var includes: [String] {
    get {return _storage._includes}
    set {_uniqueStorage()._includes = newValue}
  }

  var excludes: [String] {
    get {return _storage._excludes}
    set {_uniqueStorage()._excludes = newValue}
  }

  var runAt: String {
    get {return _storage._runAt}
    set {_uniqueStorage()._runAt = newValue}
  }

  var injectInto: String {
    get {return _storage._injectInto}
    set {_uniqueStorage()._injectInto = newValue}
  }

  var grant: [String] {
    get {return _storage._grant}
    set {_uniqueStorage()._grant = newValue}
  }

  var isLocal: Bool {
    get {return _storage._isLocal}
    set {_uniqueStorage()._isLocal = newValue}
  }

  var updateURL: String {
    get {return _storage._updateURL ?? String()}
    set {_uniqueStorage()._updateURL = newValue}
  }
  /// Returns true if `updateURL` has been explicitly set.
  var hasUpdateURL: Bool {return _storage._updateURL != nil}
  /// Clears the value of `updateURL`. Subsequent reads from it will return its default value.
  mutating func clearUpdateURL() {_uniqueStorage()._updateURL = nil}

  var downloadURL: String {
    get {return _storage._downloadURL ?? String()}
    set {_uniqueStorage()._downloadURL = newValue}
  }
  /// Returns true if `downloadURL` has been explicitly set.
  var hasDownloadURL: Bool {return _storage._downloadURL != nil}
  /// Clears the value of `downloadURL`. Subsequent reads from it will return its default value.
  mutating func clearDownloadURL() {_uniqueStorage()._downloadURL = nil}

  var content: String {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  var lastUpdated: Int64 {
    get {return _storage._lastUpdated}
    set {_uniqueStorage()._lastUpdated = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Whitelist/disabled sites data
struct Wblock_Data_WhitelistData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var disabledSites: [String] = []

  var lastUpdated: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Rule count tracking data
struct Wblock_Data_RuleCountData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lastRuleCount: Int32 = 0

  var ruleCountsByCategory: Dictionary<String,Int32> = [:]

  var categoriesApproachingLimit: [String] = []

  var lastUpdated: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Performance and timing data
struct Wblock_Data_PerformanceData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lastConversionTime: String = String()

  var lastReloadTime: String = String()

  var lastFastUpdateTime: String = String()

  var fastUpdateCount: Int32 = 0

  var sourceRulesCount: Int32 = 0

  var conversionStageDescription: String = String()

  var currentFilterName: String = String()

  var processedFiltersCount: Int32 = 0

  var totalFiltersCount: Int32 = 0

  var currentPlatform: Wblock_Data_Platform = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Per-host element zapper rule list
struct Wblock_Data_ZapperRuleList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var selectors: [String] = []

  var pendingDeletions: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Extension-specific data for Safari extensions
struct Wblock_Data_ExtensionData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tabBlockedRequests: Dictionary<String,Wblock_Data_TabData> = [:]

  var zapperRules: [String] = []

  var lastUpdated: Int64 = 0

  var zapperRulesByHost: Dictionary<String,Wblock_Data_ZapperRuleList> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Tab-specific blocking data
struct Wblock_Data_TabData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blockedCount: Int32 = 0

  var isDisabled: Bool = false

  var host: String = String()

  var lastUpdated: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Auto-update metadata and scheduling
struct Wblock_Data_AutoUpdateMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var intervalHours: Double = 0

  var lastCheckTime: Int64 = 0

  var lastSuccessfulTime: Int64 = 0

  var nextEligibleTime: Int64 = 0

  var forceNext: Bool = false

  var isRunning: Bool = false

  var runningSinceTimestamp: Int64 = 0

  /// UUID -> ETag header value
  var filterEtags: Dictionary<String,String> = [:]

  /// UUID -> Last-Modified header value
  var filterLastModified: Dictionary<String,String> = [:]

  var userscriptsInitialSetupCompleted: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "wblock.data"

extension Wblock_Data_FilterListCategory: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FILTER_LIST_CATEGORY_UNSPECIFIED"),
    1: .same(proto: "FILTER_LIST_CATEGORY_ALL"),
    2: .same(proto: "FILTER_LIST_CATEGORY_ADS"),
    3: .same(proto: "FILTER_LIST_CATEGORY_PRIVACY"),
    4: .same(proto: "FILTER_LIST_CATEGORY_SECURITY"),
    5: .same(proto: "FILTER_LIST_CATEGORY_MULTIPURPOSE"),
    6: .same(proto: "FILTER_LIST_CATEGORY_ANNOYANCES"),
    7: .same(proto: "FILTER_LIST_CATEGORY_EXPERIMENTAL"),
    8: .same(proto: "FILTER_LIST_CATEGORY_CUSTOM"),
    9: .same(proto: "FILTER_LIST_CATEGORY_FOREIGN"),
    10: .same(proto: "FILTER_LIST_CATEGORY_SCRIPTS"),
  ]
}

extension Wblock_Data_Platform: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PLATFORM_UNSPECIFIED"),
    1: .same(proto: "PLATFORM_MACOS"),
    2: .same(proto: "PLATFORM_IOS"),
  ]
}

extension Wblock_Data_AppData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "settings"),
    2: .standard(proto: "filter_lists"),
    3: .standard(proto: "user_scripts"),
    4: .same(proto: "whitelist"),
    5: .standard(proto: "rule_counts"),
    6: .same(proto: "performance"),
    7: .standard(proto: "auto_update"),
    8: .standard(proto: "extension_data"),
  ]

  fileprivate class _StorageClass {
    var _settings: Wblock_Data_AppSettings? = nil
    var _filterLists: [Wblock_Data_FilterListData] = []
    var _userScripts: [Wblock_Data_UserScriptData] = []
    var _whitelist: Wblock_Data_WhitelistData? = nil
    var _ruleCounts: Wblock_Data_RuleCountData? = nil
    var _performance: Wblock_Data_PerformanceData? = nil
    var _autoUpdate: Wblock_Data_AutoUpdateMetadata? = nil
    var _extensionData: Wblock_Data_ExtensionData? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _settings = source._settings
      _filterLists = source._filterLists
      _userScripts = source._userScripts
      _whitelist = source._whitelist
      _ruleCounts = source._ruleCounts
      _performance = source._performance
      _autoUpdate = source._autoUpdate
      _extensionData = source._extensionData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._settings) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._filterLists) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._userScripts) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._whitelist) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._ruleCounts) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._performance) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._autoUpdate) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._extensionData) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._settings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._filterLists.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._filterLists, fieldNumber: 2)
      }
      if !_storage._userScripts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._userScripts, fieldNumber: 3)
      }
      try { if let v = _storage._whitelist {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._ruleCounts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._performance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._autoUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._extensionData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wblock_Data_AppData, rhs: Wblock_Data_AppData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._settings != rhs_storage._settings {return false}
        if _storage._filterLists != rhs_storage._filterLists {return false}
        if _storage._userScripts != rhs_storage._userScripts {return false}
        if _storage._whitelist != rhs_storage._whitelist {return false}
        if _storage._ruleCounts != rhs_storage._ruleCounts {return false}
        if _storage._performance != rhs_storage._performance {return false}
        if _storage._autoUpdate != rhs_storage._autoUpdate {return false}
        if _storage._extensionData != rhs_storage._extensionData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wblock_Data_AppSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "has_completed_onboarding"),
    2: .standard(proto: "selected_blocking_level"),
    3: .standard(proto: "last_update_check"),
    4: .standard(proto: "show_advanced_features"),
    5: .standard(proto: "app_version"),
    6: .standard(proto: "last_terminology_sanitization_version"),
    7: .standard(proto: "has_enabled_content_blockers"),
    8: .standard(proto: "has_enabled_platform_extension"),
    9: .standard(proto: "has_set_all_websites_permission"),
    10: .standard(proto: "userscript_show_enabled_only"),
    11: .standard(proto: "excluded_default_userscript_urls"),
    12: .standard(proto: "is_foreign_filters_expanded"),
    13: .standard(proto: "is_badge_counter_enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.hasCompletedOnboarding_p) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.selectedBlockingLevel) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.lastUpdateCheck) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.showAdvancedFeatures) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.appVersion) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.lastTerminologySanitizationVersion) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.hasEnabledContentBlockers_p) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.hasEnabledPlatformExtension_p) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.hasSetAllWebsitesPermission_p) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.userscriptShowEnabledOnly) }()
      case 11: try { try decoder.decodeRepeatedStringField(value: &self.excludedDefaultUserscriptUrls) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.isForeignFiltersExpanded) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.isBadgeCounterEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hasCompletedOnboarding_p != false {
      try visitor.visitSingularBoolField(value: self.hasCompletedOnboarding_p, fieldNumber: 1)
    }
    if !self.selectedBlockingLevel.isEmpty {
      try visitor.visitSingularStringField(value: self.selectedBlockingLevel, fieldNumber: 2)
    }
    if self.lastUpdateCheck != 0 {
      try visitor.visitSingularInt64Field(value: self.lastUpdateCheck, fieldNumber: 3)
    }
    if self.showAdvancedFeatures != false {
      try visitor.visitSingularBoolField(value: self.showAdvancedFeatures, fieldNumber: 4)
    }
    if !self.appVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appVersion, fieldNumber: 5)
    }
    if self.lastTerminologySanitizationVersion != 0 {
      try visitor.visitSingularInt32Field(value: self.lastTerminologySanitizationVersion, fieldNumber: 6)
    }
    if self.hasEnabledContentBlockers_p != false {
      try visitor.visitSingularBoolField(value: self.hasEnabledContentBlockers_p, fieldNumber: 7)
    }
    if self.hasEnabledPlatformExtension_p != false {
      try visitor.visitSingularBoolField(value: self.hasEnabledPlatformExtension_p, fieldNumber: 8)
    }
    if self.hasSetAllWebsitesPermission_p != false {
      try visitor.visitSingularBoolField(value: self.hasSetAllWebsitesPermission_p, fieldNumber: 9)
    }
    if self.userscriptShowEnabledOnly != false {
      try visitor.visitSingularBoolField(value: self.userscriptShowEnabledOnly, fieldNumber: 10)
    }
    if !self.excludedDefaultUserscriptUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.excludedDefaultUserscriptUrls, fieldNumber: 11)
    }
    if self.isForeignFiltersExpanded != false {
      try visitor.visitSingularBoolField(value: self.isForeignFiltersExpanded, fieldNumber: 12)
    }
    if self.isBadgeCounterEnabled != false {
      try visitor.visitSingularBoolField(value: self.isBadgeCounterEnabled, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wblock_Data_AppSettings, rhs: Wblock_Data_AppSettings) -> Bool {
    if lhs.hasCompletedOnboarding_p != rhs.hasCompletedOnboarding_p {return false}
    if lhs.selectedBlockingLevel != rhs.selectedBlockingLevel {return false}
    if lhs.lastUpdateCheck != rhs.lastUpdateCheck {return false}
    if lhs.showAdvancedFeatures != rhs.showAdvancedFeatures {return false}
    if lhs.appVersion != rhs.appVersion {return false}
    if lhs.lastTerminologySanitizationVersion != rhs.lastTerminologySanitizationVersion {return false}
    if lhs.hasEnabledContentBlockers_p != rhs.hasEnabledContentBlockers_p {return false}
    if lhs.hasEnabledPlatformExtension_p != rhs.hasEnabledPlatformExtension_p {return false}
    if lhs.hasSetAllWebsitesPermission_p != rhs.hasSetAllWebsitesPermission_p {return false}
    if lhs.userscriptShowEnabledOnly != rhs.userscriptShowEnabledOnly {return false}
    if lhs.excludedDefaultUserscriptUrls != rhs.excludedDefaultUserscriptUrls {return false}
    if lhs.isForeignFiltersExpanded != rhs.isForeignFiltersExpanded {return false}
    if lhs.isBadgeCounterEnabled != rhs.isBadgeCounterEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wblock_Data_FilterListData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FilterListData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "url"),
    4: .same(proto: "category"),
    5: .standard(proto: "is_selected"),
    6: .same(proto: "description"),
    7: .same(proto: "version"),
    8: .standard(proto: "source_rule_count"),
    9: .standard(proto: "last_updated"),
    10: .standard(proto: "is_custom"),
    11: .standard(proto: "local_file_path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isSelected) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self._sourceRuleCount) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.lastUpdated) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.isCustom) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.localFilePath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 3)
    }
    if self.category != .unspecified {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 4)
    }
    if self.isSelected != false {
      try visitor.visitSingularBoolField(value: self.isSelected, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 7)
    }
    try { if let v = self._sourceRuleCount {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
    } }()
    if self.lastUpdated != 0 {
      try visitor.visitSingularInt64Field(value: self.lastUpdated, fieldNumber: 9)
    }
    if self.isCustom != false {
      try visitor.visitSingularBoolField(value: self.isCustom, fieldNumber: 10)
    }
    if !self.localFilePath.isEmpty {
      try visitor.visitSingularStringField(value: self.localFilePath, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wblock_Data_FilterListData, rhs: Wblock_Data_FilterListData) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.category != rhs.category {return false}
    if lhs.isSelected != rhs.isSelected {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.version != rhs.version {return false}
    if lhs._sourceRuleCount != rhs._sourceRuleCount {return false}
    if lhs.lastUpdated != rhs.lastUpdated {return false}
    if lhs.isCustom != rhs.isCustom {return false}
    if lhs.localFilePath != rhs.localFilePath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wblock_Data_UserScriptData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserScriptData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "url"),
    4: .standard(proto: "is_enabled"),
    5: .same(proto: "description"),
    6: .same(proto: "version"),
    7: .same(proto: "matches"),
    8: .standard(proto: "exclude_matches"),
    9: .same(proto: "includes"),
    10: .same(proto: "excludes"),
    11: .standard(proto: "run_at"),
    12: .standard(proto: "inject_into"),
    13: .same(proto: "grant"),
    14: .standard(proto: "is_local"),
    15: .standard(proto: "update_url"),
    16: .standard(proto: "download_url"),
    17: .same(proto: "content"),
    18: .standard(proto: "last_updated"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _name: String = String()
    var _url: String? = nil
    var _isEnabled: Bool = false
    var _description_p: String = String()
    var _version: String = String()
    var _matches: [String] = []
    var _excludeMatches: [String] = []
    var _includes: [String] = []
    var _excludes: [String] = []
    var _runAt: String = String()
    var _injectInto: String = String()
    var _grant: [String] = []
    var _isLocal: Bool = false
    var _updateURL: String? = nil
    var _downloadURL: String? = nil
    var _content: String = String()
    var _lastUpdated: Int64 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _url = source._url
      _isEnabled = source._isEnabled
      _description_p = source._description_p
      _version = source._version
      _matches = source._matches
      _excludeMatches = source._excludeMatches
      _includes = source._includes
      _excludes = source._excludes
      _runAt = source._runAt
      _injectInto = source._injectInto
      _grant = source._grant
      _isLocal = source._isLocal
      _updateURL = source._updateURL
      _downloadURL = source._downloadURL
      _content = source._content
      _lastUpdated = source._lastUpdated
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._isEnabled) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._matches) }()
        case 8: try { try decoder.decodeRepeatedStringField(value: &_storage._excludeMatches) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._includes) }()
        case 10: try { try decoder.decodeRepeatedStringField(value: &_storage._excludes) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._runAt) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._injectInto) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._grant) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._isLocal) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._updateURL) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._downloadURL) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._content) }()
        case 18: try { try decoder.decodeSingularInt64Field(value: &_storage._lastUpdated) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      try { if let v = _storage._url {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      if _storage._isEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._isEnabled, fieldNumber: 4)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 5)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 6)
      }
      if !_storage._matches.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._matches, fieldNumber: 7)
      }
      if !_storage._excludeMatches.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._excludeMatches, fieldNumber: 8)
      }
      if !_storage._includes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._includes, fieldNumber: 9)
      }
      if !_storage._excludes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._excludes, fieldNumber: 10)
      }
      if !_storage._runAt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._runAt, fieldNumber: 11)
      }
      if !_storage._injectInto.isEmpty {
        try visitor.visitSingularStringField(value: _storage._injectInto, fieldNumber: 12)
      }
      if !_storage._grant.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._grant, fieldNumber: 13)
      }
      if _storage._isLocal != false {
        try visitor.visitSingularBoolField(value: _storage._isLocal, fieldNumber: 14)
      }
      try { if let v = _storage._updateURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._downloadURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      } }()
      if !_storage._content.isEmpty {
        try visitor.visitSingularStringField(value: _storage._content, fieldNumber: 17)
      }
      if _storage._lastUpdated != 0 {
        try visitor.visitSingularInt64Field(value: _storage._lastUpdated, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wblock_Data_UserScriptData, rhs: Wblock_Data_UserScriptData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._isEnabled != rhs_storage._isEnabled {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._matches != rhs_storage._matches {return false}
        if _storage._excludeMatches != rhs_storage._excludeMatches {return false}
        if _storage._includes != rhs_storage._includes {return false}
        if _storage._excludes != rhs_storage._excludes {return false}
        if _storage._runAt != rhs_storage._runAt {return false}
        if _storage._injectInto != rhs_storage._injectInto {return false}
        if _storage._grant != rhs_storage._grant {return false}
        if _storage._isLocal != rhs_storage._isLocal {return false}
        if _storage._updateURL != rhs_storage._updateURL {return false}
        if _storage._downloadURL != rhs_storage._downloadURL {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._lastUpdated != rhs_storage._lastUpdated {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wblock_Data_WhitelistData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WhitelistData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "disabled_sites"),
    2: .standard(proto: "last_updated"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.disabledSites) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.lastUpdated) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.disabledSites.isEmpty {
      try visitor.visitRepeatedStringField(value: self.disabledSites, fieldNumber: 1)
    }
    if self.lastUpdated != 0 {
      try visitor.visitSingularInt64Field(value: self.lastUpdated, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wblock_Data_WhitelistData, rhs: Wblock_Data_WhitelistData) -> Bool {
    if lhs.disabledSites != rhs.disabledSites {return false}
    if lhs.lastUpdated != rhs.lastUpdated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wblock_Data_RuleCountData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RuleCountData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_rule_count"),
    2: .standard(proto: "rule_counts_by_category"),
    3: .standard(proto: "categories_approaching_limit"),
    4: .standard(proto: "last_updated"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.lastRuleCount) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.ruleCountsByCategory) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.categoriesApproachingLimit) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.lastUpdated) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lastRuleCount != 0 {
      try visitor.visitSingularInt32Field(value: self.lastRuleCount, fieldNumber: 1)
    }
    if !self.ruleCountsByCategory.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.ruleCountsByCategory, fieldNumber: 2)
    }
    if !self.categoriesApproachingLimit.isEmpty {
      try visitor.visitRepeatedStringField(value: self.categoriesApproachingLimit, fieldNumber: 3)
    }
    if self.lastUpdated != 0 {
      try visitor.visitSingularInt64Field(value: self.lastUpdated, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wblock_Data_RuleCountData, rhs: Wblock_Data_RuleCountData) -> Bool {
    if lhs.lastRuleCount != rhs.lastRuleCount {return false}
    if lhs.ruleCountsByCategory != rhs.ruleCountsByCategory {return false}
    if lhs.categoriesApproachingLimit != rhs.categoriesApproachingLimit {return false}
    if lhs.lastUpdated != rhs.lastUpdated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wblock_Data_PerformanceData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PerformanceData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_conversion_time"),
    2: .standard(proto: "last_reload_time"),
    3: .standard(proto: "last_fast_update_time"),
    4: .standard(proto: "fast_update_count"),
    5: .standard(proto: "source_rules_count"),
    6: .standard(proto: "conversion_stage_description"),
    7: .standard(proto: "current_filter_name"),
    8: .standard(proto: "processed_filters_count"),
    9: .standard(proto: "total_filters_count"),
    10: .standard(proto: "current_platform"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.lastConversionTime) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.lastReloadTime) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.lastFastUpdateTime) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.fastUpdateCount) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.sourceRulesCount) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.conversionStageDescription) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.currentFilterName) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.processedFiltersCount) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.totalFiltersCount) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.currentPlatform) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastConversionTime.isEmpty {
      try visitor.visitSingularStringField(value: self.lastConversionTime, fieldNumber: 1)
    }
    if !self.lastReloadTime.isEmpty {
      try visitor.visitSingularStringField(value: self.lastReloadTime, fieldNumber: 2)
    }
    if !self.lastFastUpdateTime.isEmpty {
      try visitor.visitSingularStringField(value: self.lastFastUpdateTime, fieldNumber: 3)
    }
    if self.fastUpdateCount != 0 {
      try visitor.visitSingularInt32Field(value: self.fastUpdateCount, fieldNumber: 4)
    }
    if self.sourceRulesCount != 0 {
      try visitor.visitSingularInt32Field(value: self.sourceRulesCount, fieldNumber: 5)
    }
    if !self.conversionStageDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.conversionStageDescription, fieldNumber: 6)
    }
    if !self.currentFilterName.isEmpty {
      try visitor.visitSingularStringField(value: self.currentFilterName, fieldNumber: 7)
    }
    if self.processedFiltersCount != 0 {
      try visitor.visitSingularInt32Field(value: self.processedFiltersCount, fieldNumber: 8)
    }
    if self.totalFiltersCount != 0 {
      try visitor.visitSingularInt32Field(value: self.totalFiltersCount, fieldNumber: 9)
    }
    if self.currentPlatform != .unspecified {
      try visitor.visitSingularEnumField(value: self.currentPlatform, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wblock_Data_PerformanceData, rhs: Wblock_Data_PerformanceData) -> Bool {
    if lhs.lastConversionTime != rhs.lastConversionTime {return false}
    if lhs.lastReloadTime != rhs.lastReloadTime {return false}
    if lhs.lastFastUpdateTime != rhs.lastFastUpdateTime {return false}
    if lhs.fastUpdateCount != rhs.fastUpdateCount {return false}
    if lhs.sourceRulesCount != rhs.sourceRulesCount {return false}
    if lhs.conversionStageDescription != rhs.conversionStageDescription {return false}
    if lhs.currentFilterName != rhs.currentFilterName {return false}
    if lhs.processedFiltersCount != rhs.processedFiltersCount {return false}
    if lhs.totalFiltersCount != rhs.totalFiltersCount {return false}
    if lhs.currentPlatform != rhs.currentPlatform {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wblock_Data_ExtensionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExtensionData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tab_blocked_requests"),
    2: .standard(proto: "zapper_rules"),
    3: .standard(proto: "last_updated"),
    4: .standard(proto: "zapper_rules_by_host"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Wblock_Data_TabData>.self, value: &self.tabBlockedRequests) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.zapperRules) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.lastUpdated) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Wblock_Data_ZapperRuleList>.self, value: &self.zapperRulesByHost) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tabBlockedRequests.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Wblock_Data_TabData>.self, value: self.tabBlockedRequests, fieldNumber: 1)
    }
    if !self.zapperRules.isEmpty {
      try visitor.visitRepeatedStringField(value: self.zapperRules, fieldNumber: 2)
    }
    if self.lastUpdated != 0 {
      try visitor.visitSingularInt64Field(value: self.lastUpdated, fieldNumber: 3)
    }
    if !self.zapperRulesByHost.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Wblock_Data_ZapperRuleList>.self, value: self.zapperRulesByHost, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wblock_Data_ExtensionData, rhs: Wblock_Data_ExtensionData) -> Bool {
    if lhs.tabBlockedRequests != rhs.tabBlockedRequests {return false}
    if lhs.zapperRules != rhs.zapperRules {return false}
    if lhs.lastUpdated != rhs.lastUpdated {return false}
    if lhs.zapperRulesByHost != rhs.zapperRulesByHost {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wblock_Data_ZapperRuleList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ZapperRuleList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "selectors"),
    2: .standard(proto: "pending_deletions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.selectors) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.pendingDeletions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.selectors.isEmpty {
      try visitor.visitRepeatedStringField(value: self.selectors, fieldNumber: 1)
    }
    if !self.pendingDeletions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pendingDeletions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wblock_Data_ZapperRuleList, rhs: Wblock_Data_ZapperRuleList) -> Bool {
    if lhs.selectors != rhs.selectors {return false}
    if lhs.pendingDeletions != rhs.pendingDeletions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wblock_Data_TabData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TabData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "blocked_count"),
    2: .standard(proto: "is_disabled"),
    3: .same(proto: "host"),
    4: .standard(proto: "last_updated"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.blockedCount) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isDisabled) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.lastUpdated) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.blockedCount != 0 {
      try visitor.visitSingularInt32Field(value: self.blockedCount, fieldNumber: 1)
    }
    if self.isDisabled != false {
      try visitor.visitSingularBoolField(value: self.isDisabled, fieldNumber: 2)
    }
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 3)
    }
    if self.lastUpdated != 0 {
      try visitor.visitSingularInt64Field(value: self.lastUpdated, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wblock_Data_TabData, rhs: Wblock_Data_TabData) -> Bool {
    if lhs.blockedCount != rhs.blockedCount {return false}
    if lhs.isDisabled != rhs.isDisabled {return false}
    if lhs.host != rhs.host {return false}
    if lhs.lastUpdated != rhs.lastUpdated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wblock_Data_AutoUpdateMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AutoUpdateMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "interval_hours"),
    3: .standard(proto: "last_check_time"),
    4: .standard(proto: "last_successful_time"),
    5: .standard(proto: "next_eligible_time"),
    6: .standard(proto: "force_next"),
    7: .standard(proto: "is_running"),
    8: .standard(proto: "running_since_timestamp"),
    9: .standard(proto: "filter_etags"),
    10: .standard(proto: "filter_last_modified"),
    11: .standard(proto: "userscripts_initial_setup_completed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.intervalHours) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.lastCheckTime) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.lastSuccessfulTime) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.nextEligibleTime) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.forceNext) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isRunning) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.runningSinceTimestamp) }()
      case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.filterEtags) }()
      case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.filterLastModified) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.userscriptsInitialSetupCompleted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.intervalHours.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.intervalHours, fieldNumber: 2)
    }
    if self.lastCheckTime != 0 {
      try visitor.visitSingularInt64Field(value: self.lastCheckTime, fieldNumber: 3)
    }
    if self.lastSuccessfulTime != 0 {
      try visitor.visitSingularInt64Field(value: self.lastSuccessfulTime, fieldNumber: 4)
    }
    if self.nextEligibleTime != 0 {
      try visitor.visitSingularInt64Field(value: self.nextEligibleTime, fieldNumber: 5)
    }
    if self.forceNext != false {
      try visitor.visitSingularBoolField(value: self.forceNext, fieldNumber: 6)
    }
    if self.isRunning != false {
      try visitor.visitSingularBoolField(value: self.isRunning, fieldNumber: 7)
    }
    if self.runningSinceTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.runningSinceTimestamp, fieldNumber: 8)
    }
    if !self.filterEtags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.filterEtags, fieldNumber: 9)
    }
    if !self.filterLastModified.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.filterLastModified, fieldNumber: 10)
    }
    if self.userscriptsInitialSetupCompleted != false {
      try visitor.visitSingularBoolField(value: self.userscriptsInitialSetupCompleted, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wblock_Data_AutoUpdateMetadata, rhs: Wblock_Data_AutoUpdateMetadata) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.intervalHours != rhs.intervalHours {return false}
    if lhs.lastCheckTime != rhs.lastCheckTime {return false}
    if lhs.lastSuccessfulTime != rhs.lastSuccessfulTime {return false}
    if lhs.nextEligibleTime != rhs.nextEligibleTime {return false}
    if lhs.forceNext != rhs.forceNext {return false}
    if lhs.isRunning != rhs.isRunning {return false}
    if lhs.runningSinceTimestamp != rhs.runningSinceTimestamp {return false}
    if lhs.filterEtags != rhs.filterEtags {return false}
    if lhs.filterLastModified != rhs.filterLastModified {return false}
    if lhs.userscriptsInitialSetupCompleted != rhs.userscriptsInitialSetupCompleted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
